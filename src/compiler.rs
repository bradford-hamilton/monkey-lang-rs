use crate::ast::{Expression, Node, Statement};
use crate::builtins::BUILTINS;
use crate::bytecode::make_instruction;
use crate::bytecode::{Instructions, Opcode};
use crate::object::{CompiledFuncObject, Object};
use crate::symbol_table::{Symbol, SymbolScope, SymbolTable};

/// Bytecode contains the Instructions our compiler
/// generated and the constants the compiler evaluated.
pub struct Bytecode<'a> {
    pub instructions: Instructions,
    pub constants: Vec<Object<'a>>,
}

#[derive(Copy, Clone)]
/// Represents an instruction through an opcode and it's position.
struct EmittedInstruction {
    opcode: Opcode,
    position: usize,
}

impl EmittedInstruction {
    fn new(opcode: Opcode, position: usize) -> Self {
        EmittedInstruction { opcode, position }
    }
}

/// Before we start compiling a function's body (enter a new scope) we push
/// a new CompilationScope on to the scopes stack. While compiling inside
/// this scope, the emit method of the compiler will modify only the fields
/// of the current CompilationScope. Once we're done compiling the function,
/// we leave the scope by popping it off the scopes stack and putting the
/// instructions in a new object::CompiledFunc
struct CompilationScope {
    instructions: Instructions,
    last_instruction: EmittedInstruction,
    prev_instruction: EmittedInstruction,
}

/// defines our compiler with instructions which hold the generated bytecode,
/// constants which serve as our constant pool, and the last and previous
/// instructions
pub struct Compiler<'a> {
    constants: Vec<Object<'a>>,
    symbol_table: SymbolTable,
    scopes: Vec<CompilationScope>,
    scope_index: i64,
}

impl<'a> Compiler<'a> {
    pub fn new() -> Self {
        let main_scope = CompilationScope {
            instructions: Instructions::new(vec![]),
            last_instruction: EmittedInstruction::new(Opcode::OpNull, 0),
            prev_instruction: EmittedInstruction::new(Opcode::OpNull, 0),
        };
        let mut symbol_table = SymbolTable::new();

        for (i, v) in BUILTINS.iter().enumerate() {
            symbol_table.define_builtin(i as i64, v.0.clone());
        }

        Compiler {
            constants: vec![],
            symbol_table,
            scopes: vec![main_scope],
            scope_index: 0,
        }
    }

    pub fn bytecode(&self) -> Bytecode {
        Bytecode {
            instructions: self.current_instructions(),
            constants: self.constants,
        }
    }

    fn current_instructions(&self) -> Instructions {
        self.scopes[self.scope_index as usize].instructions.clone()
    }

    fn current_instructions_mut(&mut self) -> &mut Instructions {
        &mut self.scopes[self.scope_index as usize].instructions
    }

    pub fn emit(&mut self, op: Opcode, operands: Vec<i32>) -> i64 {
        let ins = make_instruction(op, operands);
        let pos = self.add_instruction(ins);

        self.set_last_instruction(op, pos as usize);

        pos
    }

    fn add_instruction(&mut self, instruction: Vec<u8>) -> i64 {
        let new_instruction_pos = self.current_instructions().len();
        self.scopes[self.scope_index as usize]
            .instructions
            .extend(instruction);

        new_instruction_pos
    }

    fn set_last_instruction(&mut self, op: Opcode, pos: usize) {
        let previous = self.scopes[self.scope_index as usize].last_instruction;
        let last = EmittedInstruction::new(op, pos);

        self.scopes[self.scope_index as usize].prev_instruction = previous;
        self.scopes[self.scope_index as usize].last_instruction = last;
    }

    pub fn add_constant(&mut self, obj: Object) -> usize {
        self.constants.push(obj);
        self.constants.len() - 1
    }

    fn load_symbol(&mut self, symbol: Symbol) {
        match symbol.scope {
            SymbolScope::Global => {
                self.emit(Opcode::OpGetGlobal, vec![symbol.index as i32]);
            }
            SymbolScope::Local => {
                self.emit(Opcode::OpGetLocal, vec![symbol.index as i32]);
            }
            SymbolScope::Builtin => {
                self.emit(Opcode::OpGetBuiltin, vec![symbol.index as i32]);
            }
            SymbolScope::Free => {
                self.emit(Opcode::OpGetFree, vec![symbol.index as i32]);
            }
            SymbolScope::Function => {
                self.emit(Opcode::OpCurrentClosure, vec![]);
            }
        }
    }

    fn enter_scope(&mut self) {
        let scope = CompilationScope {
            instructions: Instructions::new(vec![]),
            last_instruction: EmittedInstruction::new(Opcode::OpNull, 0),
            prev_instruction: EmittedInstruction::new(Opcode::OpNull, 0),
        };
        self.scopes.push(scope);
        self.scope_index += 1;
        self.symbol_table = SymbolTable::new_enclosed(Some(Box::new(self.symbol_table.clone())));
    }

    pub fn leave_scope(&mut self) -> Instructions {
        let instructions = self.current_instructions();
        self.scopes.pop();
        self.scope_index -= 1;

        if let Some(outer_symbol_table) = self.symbol_table.get_outer() {
            self.symbol_table = *outer_symbol_table;
        }

        instructions
    }

    fn change_operand(&mut self, op_pos: i64, operand: i64) {
        let op = self.current_instructions()[op_pos.try_into().unwrap()];
        let new_instruction = make_instruction(Opcode::from(op), vec![operand as i32]);
        self.replace_instruction(op_pos, new_instruction);
    }

    fn replace_instruction(&mut self, position: i64, new_instruction: Vec<u8>) {
        let ins = self.current_instructions_mut();
        for (i, byte) in new_instruction.iter().enumerate() {
            ins[position as usize + i] = *byte;
        }
    }

    fn last_instruction_is(&self, op: Opcode) -> bool {
        if self.current_instructions().len() == 0 {
            return false;
        }
        self.scopes
            .get(self.scope_index as usize)
            .map_or(false, |scope| {
                let last_instr = &scope.last_instruction;
                last_instr.opcode == op
            })
    }

    fn remove_last_pop(&mut self) {
        if let Some(scope) = self.scopes.get_mut(self.scope_index as usize) {
            let last_instr = scope.last_instruction;
            let new_instructions_slice = &scope.instructions.as_vec_u8()[..last_instr.position];
            let new_instructions = Instructions::new(new_instructions_slice.to_vec());
            scope.instructions = new_instructions;
            scope.last_instruction = scope.prev_instruction;
        }
    }

    fn replace_last_pop_with_return(&mut self) {
        let last_pos = if let Some(scope) = self.scopes.get(self.scope_index as usize) {
            scope.last_instruction.position
        } else {
            return; // TODO: what happens in this situation?
        };

        let return_instruction = make_instruction(Opcode::OpReturnValue, vec![]);
        self.replace_instruction(last_pos as i64, return_instruction);

        if let Some(scope) = self.scopes.get_mut(self.scope_index as usize) {
            scope.last_instruction.opcode = Opcode::OpReturnValue;
        }
    }

    // TODO: PostfixExpression after implementing them.
    pub fn compile(&mut self, node: &Node) -> Result<(), String> {
        match node {
            Node::Root(root_node) => {
                for statement in &root_node.statements {
                    self.compile(&Node::Statement(*statement))?;
                }
            }
            Node::Statement(Statement::Expression(expression_stmt)) => {
                self.compile(&Node::Expression(expression_stmt.expression))?;
                self.emit(Opcode::OpPop, vec![]);
            }
            Node::Expression(Expression::Infix(infix_expr)) => {
                if infix_expr.operator == "<" || infix_expr.operator == "<=" {
                    self.compile(&Node::Expression(*infix_expr.right))?;
                    self.compile(&Node::Expression(*infix_expr.left))?;
                    match infix_expr.operator.as_str() {
                        "<" => {
                            self.emit(Opcode::OpGreater, vec![]);
                        }
                        _ => {
                            self.emit(Opcode::OpGreaterEqual, vec![]);
                        }
                    }
                } else {
                    self.compile(&Node::Expression(*infix_expr.left))?;
                    self.compile(&Node::Expression(*infix_expr.right))?;

                    match infix_expr.operator.as_str() {
                        "+" => {
                            self.emit(Opcode::OpAdd, vec![]);
                        }
                        "-" => {
                            self.emit(Opcode::OpSub, vec![]);
                        }
                        "*" => {
                            self.emit(Opcode::OpMul, vec![]);
                        }
                        "/" => {
                            self.emit(Opcode::OpDiv, vec![]);
                        }
                        "%" => {
                            self.emit(Opcode::OpMod, vec![]);
                        }
                        ">" => {
                            self.emit(Opcode::OpGreater, vec![]);
                        }
                        ">=" => {
                            self.emit(Opcode::OpGreaterEqual, vec![]);
                        }
                        "==" => {
                            self.emit(Opcode::OpEqualEqual, vec![]);
                        }
                        "!=" => {
                            self.emit(Opcode::OpNotEqual, vec![]);
                        }
                        "&&" => {
                            self.emit(Opcode::OpAnd, vec![]);
                        }
                        "||" => {
                            self.emit(Opcode::OpOr, vec![]);
                        }
                        _ => return Err(format!("unknown operator {}", infix_expr.operator)),
                    }
                }
            }
            Node::Expression(Expression::Integer(int_literal)) => {
                let integer = Object::Integer(int_literal.value);
                let constant_index = self.add_constant(integer);
                self.emit(Opcode::OpConstant, vec![constant_index as i32]);
            }
            Node::Expression(Expression::Boolean(boolean)) => {
                if boolean.value {
                    self.emit(Opcode::OpTrue, vec![]);
                } else {
                    self.emit(Opcode::OpFalse, vec![]);
                }
            }
            Node::Expression(Expression::Prefix(prefix_expr)) => {
                self.compile(&Node::Expression(*prefix_expr.right))?;

                match prefix_expr.operator.as_str() {
                    "!" => {
                        self.emit(Opcode::OpBang, vec![]);
                    }
                    "-" => {
                        self.emit(Opcode::OpMinus, vec![]);
                    }
                    _ => return Err(format!("unknown operator {}", prefix_expr.operator)),
                }
            }
            Node::Expression(Expression::If(if_expr)) => {
                self.compile(&Node::Expression(*if_expr.condition))?;

                let jump_not_truthy_pos = self.emit(Opcode::OpJumpNotTruthy, vec![9999]);
                self.compile(&Node::Statement(Statement::Block(if_expr.consequence)))?;

                if self.last_instruction_is(Opcode::OpPop) {
                    self.remove_last_pop();
                }

                let jump_position = self.emit(Opcode::OpJump, vec![9999]);
                let after_consequence_pos = self.current_instructions().len();
                self.change_operand(jump_not_truthy_pos, after_consequence_pos);

                if if_expr.alternative.statements.len() > 0 {
                    for stmt in &if_expr.alternative.statements {
                        self.compile(&Node::Statement(*stmt))?;
                    }

                    if self.last_instruction_is(Opcode::OpPop) {
                        self.remove_last_pop();
                    }
                } else {
                    self.emit(Opcode::OpNull, vec![]);
                }

                let after_alt_pos = self.current_instructions().len();
                self.change_operand(jump_position, after_alt_pos);
            }
            Node::Statement(Statement::Block(block_stmt)) => {
                for statement in &block_stmt.statements {
                    self.compile(&Node::Statement(*statement))?;
                }
            }
            Node::Statement(Statement::Let(let_stmt)) => {
                let symbol = self.symbol_table.define(let_stmt.name.value);

                self.compile(&Node::Expression(let_stmt.value))?;

                match symbol.scope {
                    SymbolScope::Global => {
                        self.emit(Opcode::OpSetGlobal, vec![symbol.index as i32]);
                    }
                    _ => {
                        self.emit(Opcode::OpSetLocal, vec![symbol.index as i32]);
                    }
                }
            }
            Node::Statement(Statement::Const(const_stmt)) => {
                let symbol = self.symbol_table.define(const_stmt.name.value.clone());

                self.compile(&Node::Expression(const_stmt.value))?;

                match symbol.scope {
                    SymbolScope::Global => {
                        self.emit(Opcode::OpSetGlobal, vec![symbol.index as i32]);
                    }
                    _ => {
                        self.emit(Opcode::OpSetLocal, vec![symbol.index as i32]);
                    }
                }
            }
            Node::Expression(Expression::Identifier(identifier)) => {
                match self.symbol_table.resolve(&identifier.value) {
                    Some(symbol) => self.load_symbol(symbol),
                    None => return Err(format!("undefined variable {}", identifier.value)),
                }
            }
            Node::Expression(Expression::String(string_lit)) => {
                let string_obj = Object::Str(string_lit.value);
                let constant_index = self.add_constant(string_obj);
                self.emit(Opcode::OpConstant, vec![constant_index as i32]);
            }
            Node::Expression(Expression::Array(array_literal)) => {
                for el in &array_literal.elements {
                    self.compile(&Node::Expression(*el))?;
                }
                self.emit(Opcode::OpArray, vec![array_literal.elements.len() as i32]);
            }
            Node::Expression(Expression::Hash(hash_literal)) => {
                let mut keys: Vec<_> = hash_literal.pairs.keys().collect();

                // Sort keys based on their string representation
                keys.sort_by(|a, b| a.string().cmp(&b.string()));

                for key in keys {
                    // Compile the key
                    self.compile(&Node::Expression(*key))?;

                    // Compile the value associated with the key
                    let value = hash_literal
                        .pairs
                        .get(key)
                        .ok_or("key not found in hash literal".to_string())?;
                    self.compile(&Node::Expression(*value))?;
                }
                self.emit(Opcode::OpHash, vec![hash_literal.pairs.len() as i32 * 2]);
            }
            Node::Expression(Expression::Index(index_expr)) => {
                self.compile(&Node::Expression(*index_expr.left))?;
                self.compile(&Node::Expression(*index_expr.index))?;
                self.emit(Opcode::OpIndex, vec![]);
            }
            Node::Expression(Expression::Function(func_literal)) => {
                self.enter_scope();

                // Assuming func_literal.name is a String and not a RefCell<String>
                if !func_literal.name.is_empty() {
                    self.symbol_table.define_function(func_literal.name);
                }

                for param in &func_literal.parameters {
                    self.symbol_table.define(param.value);
                }

                self.compile(&Node::Statement(Statement::Block(func_literal.body)))?;

                if self.last_instruction_is(Opcode::OpPop) {
                    self.replace_last_pop_with_return();
                }
                if !self.last_instruction_is(Opcode::OpReturnValue) {
                    self.emit(Opcode::OpReturn, vec![]);
                }

                let free_symbols = self.symbol_table.free_symbols;
                let free_symbols_len = free_symbols.len();
                let num_locals = self.symbol_table.num_definitions;
                let instructions = self.leave_scope();

                for symbol in free_symbols {
                    self.load_symbol(symbol);
                }

                let compiled_func = Object::CompiledFunc(&CompiledFuncObject {
                    instructions,
                    num_locals,
                    num_params: func_literal.parameters.len(),
                });

                let func_index = self.add_constant(compiled_func);
                self.emit(
                    Opcode::OpClosure,
                    vec![func_index as i32, free_symbols_len as i32],
                );
            }
            Node::Statement(Statement::Return(return_stmt)) => {
                self.compile(&Node::Expression(return_stmt.return_value))?;
                self.emit(Opcode::OpReturnValue, vec![]);
            }
            Node::Expression(Expression::Call(call_expr)) => {
                self.compile(&Node::Expression(*call_expr.function))?;

                for arg in &call_expr.arguments {
                    self.compile(&Node::Expression(*arg))?;
                }

                self.emit(Opcode::OpCall, vec![call_expr.arguments.len() as i32]);
            }
            _ => {
                return Err("Unrecognized node type".to_string());
            }
        }

        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    use crate::lexer::Lexer;
    use crate::parser::Parser;

    struct CompilerTestCase<'a> {
        input: String,
        expected_constants: Vec<Object<'a>>,
        expected_instructions: Vec<u8>,
    }

    fn run_compiler_tests(tests: Vec<CompilerTestCase>) {
        for test in tests {
            let lexer = Lexer::new(test.input);
            let mut parser = Parser::new(lexer);
            let program = parser.parse_program();
            let mut compiler = Compiler::new();

            match compiler.compile(&Node::Root(program)) {
                Ok(_) => {
                    let bytecode = compiler.bytecode();
                    assert_eq!(
                        bytecode.instructions.as_vec_u8(),
                        test.expected_instructions
                    );
                    for (i, cnst) in test.expected_constants.iter().enumerate() {
                        // Ensure the index is within bounds for bytecode.constants
                        if i < bytecode.constants.len() {
                            let test_obj_type = cnst.object_type().to_string();
                            let mut test_contents = cnst.inspect();
                            let bytecode_obj_type = bytecode.constants[i].object_type().to_string();
                            let mut bytecode_contents = bytecode.constants[i].inspect();

                            // Handle comparisons for objects that will not have full equality
                            // through the inspect() call, but are still "equal".
                            if test_obj_type == "COMPILED_FUNCTION" || test_obj_type == "CLOSURE" {
                                if let Some(start) = test_contents.find('[') {
                                    if let Some(end) = test_contents[start..].find(']') {
                                        test_contents.replace_range(start..start + end + 1, "[]");
                                        bytecode_contents
                                            .replace_range(start..start + end + 1, "[]");
                                    }
                                } else {
                                    panic!("something is incorrect with compiled functions");
                                }
                            }

                            assert_eq!(test_obj_type, bytecode_obj_type);
                            assert_eq!(test_contents, bytecode_contents);
                        } else {
                            panic!("mismatch in the number of constants between test and bytecode");
                        }
                    }
                }
                Err(e) => panic!("compiler error: {}", e),
            }
        }
    }

    #[test]
    fn test_integer_arithmetic() {
        let tests = vec![
            CompilerTestCase {
                input: "1 + 2".to_string(),
                expected_constants: vec![Object::Integer(1), Object::Integer(2)],
                expected_instructions: vec![
                    make_instruction(Opcode::OpConstant, vec![0]),
                    make_instruction(Opcode::OpConstant, vec![1]),
                    make_instruction(Opcode::OpAdd, vec![]),
                    make_instruction(Opcode::OpPop, vec![]),
                ]
                .into_iter()
                .flatten()
                .collect(),
            },
            CompilerTestCase {
                input: "1; 2".to_string(),
                expected_constants: vec![Object::Integer(1), Object::Integer(2)],
                expected_instructions: vec![
                    make_instruction(Opcode::OpConstant, vec![0]),
                    make_instruction(Opcode::OpPop, vec![]),
                    make_instruction(Opcode::OpConstant, vec![1]),
                    make_instruction(Opcode::OpPop, vec![]),
                ]
                .into_iter()
                .flatten()
                .collect(),
            },
            CompilerTestCase {
                input: "1 - 2".to_string(),
                expected_constants: vec![Object::Integer(1), Object::Integer(2)],
                expected_instructions: vec![
                    make_instruction(Opcode::OpConstant, vec![0]),
                    make_instruction(Opcode::OpConstant, vec![1]),
                    make_instruction(Opcode::OpSub, vec![]),
                    make_instruction(Opcode::OpPop, vec![]),
                ]
                .into_iter()
                .flatten()
                .collect(),
            },
            CompilerTestCase {
                input: "1 * 2".to_string(),
                expected_constants: vec![Object::Integer(1), Object::Integer(2)],
                expected_instructions: vec![
                    make_instruction(Opcode::OpConstant, vec![0]),
                    make_instruction(Opcode::OpConstant, vec![1]),
                    make_instruction(Opcode::OpMul, vec![]),
                    make_instruction(Opcode::OpPop, vec![]),
                ]
                .into_iter()
                .flatten()
                .collect(),
            },
            CompilerTestCase {
                input: "2 / 1".to_string(),
                expected_constants: vec![Object::Integer(2), Object::Integer(1)],
                expected_instructions: vec![
                    make_instruction(Opcode::OpConstant, vec![0]),
                    make_instruction(Opcode::OpConstant, vec![1]),
                    make_instruction(Opcode::OpDiv, vec![]),
                    make_instruction(Opcode::OpPop, vec![]),
                ]
                .into_iter()
                .flatten()
                .collect(),
            },
            CompilerTestCase {
                input: "2 % 1".to_string(),
                expected_constants: vec![Object::Integer(2), Object::Integer(1)],
                expected_instructions: vec![
                    make_instruction(Opcode::OpConstant, vec![0]),
                    make_instruction(Opcode::OpConstant, vec![1]),
                    make_instruction(Opcode::OpMod, vec![]),
                    make_instruction(Opcode::OpPop, vec![]),
                ]
                .into_iter()
                .flatten()
                .collect(),
            },
            CompilerTestCase {
                input: "-1".to_string(),
                expected_constants: vec![Object::Integer(1)],
                expected_instructions: vec![
                    make_instruction(Opcode::OpConstant, vec![0]),
                    make_instruction(Opcode::OpMinus, vec![]),
                    make_instruction(Opcode::OpPop, vec![]),
                ]
                .into_iter()
                .flatten()
                .collect(),
            },
        ];

        run_compiler_tests(tests);
    }

    // TODO: TestPostfixIncrementAndDecrement

    #[test]
    fn test_boolean_expressions() {
        let tests = vec![
            CompilerTestCase {
                input: "true".to_string(),
                expected_constants: vec![],
                expected_instructions: vec![
                    make_instruction(Opcode::OpTrue, vec![]),
                    make_instruction(Opcode::OpPop, vec![]),
                ]
                .into_iter()
                .flatten()
                .collect(),
            },
            CompilerTestCase {
                input: "false".to_string(),
                expected_constants: vec![],
                expected_instructions: vec![
                    make_instruction(Opcode::OpFalse, vec![]),
                    make_instruction(Opcode::OpPop, vec![]),
                ]
                .into_iter()
                .flatten()
                .collect(),
            },
            CompilerTestCase {
                input: "1 > 2".to_string(),
                expected_constants: vec![Object::Integer(1), Object::Integer(2)],
                expected_instructions: vec![
                    make_instruction(Opcode::OpConstant, vec![0]),
                    make_instruction(Opcode::OpConstant, vec![1]),
                    make_instruction(Opcode::OpGreater, vec![]),
                    make_instruction(Opcode::OpPop, vec![]),
                ]
                .into_iter()
                .flatten()
                .collect(),
            },
            CompilerTestCase {
                input: "1 < 2".to_string(),
                expected_constants: vec![Object::Integer(2), Object::Integer(1)],
                expected_instructions: vec![
                    make_instruction(Opcode::OpConstant, vec![0]),
                    make_instruction(Opcode::OpConstant, vec![1]),
                    make_instruction(Opcode::OpGreater, vec![]),
                    make_instruction(Opcode::OpPop, vec![]),
                ]
                .into_iter()
                .flatten()
                .collect(),
            },
            CompilerTestCase {
                input: "1 <= 2".to_string(),
                expected_constants: vec![Object::Integer(2), Object::Integer(1)],
                expected_instructions: vec![
                    make_instruction(Opcode::OpConstant, vec![0]),
                    make_instruction(Opcode::OpConstant, vec![1]),
                    make_instruction(Opcode::OpGreaterEqual, vec![]),
                    make_instruction(Opcode::OpPop, vec![]),
                ]
                .into_iter()
                .flatten()
                .collect(),
            },
            CompilerTestCase {
                input: "1 >= 2".to_string(),
                expected_constants: vec![Object::Integer(1), Object::Integer(2)],
                expected_instructions: vec![
                    make_instruction(Opcode::OpConstant, vec![0]),
                    make_instruction(Opcode::OpConstant, vec![1]),
                    make_instruction(Opcode::OpGreaterEqual, vec![]),
                    make_instruction(Opcode::OpPop, vec![]),
                ]
                .into_iter()
                .flatten()
                .collect(),
            },
            CompilerTestCase {
                input: "1 == 2".to_string(),
                expected_constants: vec![Object::Integer(1), Object::Integer(2)],
                expected_instructions: vec![
                    make_instruction(Opcode::OpConstant, vec![0]),
                    make_instruction(Opcode::OpConstant, vec![1]),
                    make_instruction(Opcode::OpEqualEqual, vec![]),
                    make_instruction(Opcode::OpPop, vec![]),
                ]
                .into_iter()
                .flatten()
                .collect(),
            },
            CompilerTestCase {
                input: "1 != 2".to_string(),
                expected_constants: vec![Object::Integer(1), Object::Integer(2)],
                expected_instructions: vec![
                    make_instruction(Opcode::OpConstant, vec![0]),
                    make_instruction(Opcode::OpConstant, vec![1]),
                    make_instruction(Opcode::OpNotEqual, vec![]),
                    make_instruction(Opcode::OpPop, vec![]),
                ]
                .into_iter()
                .flatten()
                .collect(),
            },
            CompilerTestCase {
                input: "true == false".to_string(),
                expected_constants: vec![],
                expected_instructions: vec![
                    make_instruction(Opcode::OpTrue, vec![]),
                    make_instruction(Opcode::OpFalse, vec![]),
                    make_instruction(Opcode::OpEqualEqual, vec![]),
                    make_instruction(Opcode::OpPop, vec![]),
                ]
                .into_iter()
                .flatten()
                .collect(),
            },
            CompilerTestCase {
                input: "true != false".to_string(),
                expected_constants: vec![],
                expected_instructions: vec![
                    make_instruction(Opcode::OpTrue, vec![]),
                    make_instruction(Opcode::OpFalse, vec![]),
                    make_instruction(Opcode::OpNotEqual, vec![]),
                    make_instruction(Opcode::OpPop, vec![]),
                ]
                .into_iter()
                .flatten()
                .collect(),
            },
            CompilerTestCase {
                input: "true && false".to_string(),
                expected_constants: vec![],
                expected_instructions: vec![
                    make_instruction(Opcode::OpTrue, vec![]),
                    make_instruction(Opcode::OpFalse, vec![]),
                    make_instruction(Opcode::OpAnd, vec![]),
                    make_instruction(Opcode::OpPop, vec![]),
                ]
                .into_iter()
                .flatten()
                .collect(),
            },
            CompilerTestCase {
                input: "true || false".to_string(),
                expected_constants: vec![],
                expected_instructions: vec![
                    make_instruction(Opcode::OpTrue, vec![]),
                    make_instruction(Opcode::OpFalse, vec![]),
                    make_instruction(Opcode::OpOr, vec![]),
                    make_instruction(Opcode::OpPop, vec![]),
                ]
                .into_iter()
                .flatten()
                .collect(),
            },
            CompilerTestCase {
                input: "!true".to_string(),
                expected_constants: vec![],
                expected_instructions: vec![
                    make_instruction(Opcode::OpTrue, vec![]),
                    make_instruction(Opcode::OpBang, vec![]),
                    make_instruction(Opcode::OpPop, vec![]),
                ]
                .into_iter()
                .flatten()
                .collect(),
            },
        ];

        run_compiler_tests(tests);
    }

    #[test]
    fn test_conditionals() {
        let tests = vec![
            CompilerTestCase {
                input: "if (true) { 10 }; 3333;".to_string(),
                expected_constants: vec![Object::Integer(10), Object::Integer(3333)],
                expected_instructions: vec![
                    make_instruction(Opcode::OpTrue, vec![]),
                    make_instruction(Opcode::OpJumpNotTruthy, vec![10]),
                    make_instruction(Opcode::OpConstant, vec![0]),
                    make_instruction(Opcode::OpJump, vec![11]),
                    make_instruction(Opcode::OpNull, vec![]),
                    make_instruction(Opcode::OpPop, vec![]),
                    make_instruction(Opcode::OpConstant, vec![1]),
                    make_instruction(Opcode::OpPop, vec![]),
                ]
                .into_iter()
                .flatten()
                .collect(),
            },
            CompilerTestCase {
                input: "if (true) { 10 } else { 20 }; 3333;".to_string(),
                expected_constants: vec![
                    Object::Integer(10),
                    Object::Integer(20),
                    Object::Integer(3333),
                ],
                expected_instructions: vec![
                    make_instruction(Opcode::OpTrue, vec![]),
                    make_instruction(Opcode::OpJumpNotTruthy, vec![10]),
                    make_instruction(Opcode::OpConstant, vec![0]),
                    make_instruction(Opcode::OpJump, vec![13]),
                    make_instruction(Opcode::OpConstant, vec![1]),
                    make_instruction(Opcode::OpPop, vec![]),
                    make_instruction(Opcode::OpConstant, vec![2]),
                    make_instruction(Opcode::OpPop, vec![]),
                ]
                .into_iter()
                .flatten()
                .collect(),
            },
        ];

        run_compiler_tests(tests);
    }

    #[test]
    fn test_global_let_statements() {
        let tests = vec![
            CompilerTestCase {
                input: "
                let one = 1;
                let two = 2;
            "
                .to_string(),
                expected_constants: vec![Object::Integer(1), Object::Integer(2)],
                expected_instructions: vec![
                    make_instruction(Opcode::OpConstant, vec![0]),
                    make_instruction(Opcode::OpSetGlobal, vec![0]),
                    make_instruction(Opcode::OpConstant, vec![1]),
                    make_instruction(Opcode::OpSetGlobal, vec![1]),
                ]
                .into_iter()
                .flatten()
                .collect(),
            },
            CompilerTestCase {
                input: "
                let one = 1;
                one;
            "
                .to_string(),
                expected_constants: vec![Object::Integer(1)],
                expected_instructions: vec![
                    make_instruction(Opcode::OpConstant, vec![0]),
                    make_instruction(Opcode::OpSetGlobal, vec![0]),
                    make_instruction(Opcode::OpGetGlobal, vec![0]),
                    make_instruction(Opcode::OpPop, vec![]),
                ]
                .into_iter()
                .flatten()
                .collect(),
            },
            CompilerTestCase {
                input: "
                let one = 1;
                let two = one;
                two;
            "
                .to_string(),
                expected_constants: vec![Object::Integer(1)],
                expected_instructions: vec![
                    make_instruction(Opcode::OpConstant, vec![0]),
                    make_instruction(Opcode::OpSetGlobal, vec![0]),
                    make_instruction(Opcode::OpGetGlobal, vec![0]),
                    make_instruction(Opcode::OpSetGlobal, vec![1]),
                    make_instruction(Opcode::OpGetGlobal, vec![1]),
                    make_instruction(Opcode::OpPop, vec![]),
                ]
                .into_iter()
                .flatten()
                .collect(),
            },
        ];

        run_compiler_tests(tests);
    }

    #[test]
    fn test_global_const_statements() {
        let tests = vec![
            CompilerTestCase {
                input: "
                const one = 1;
                const two = 2;
            "
                .to_string(),
                expected_constants: vec![Object::Integer(1), Object::Integer(2)],
                expected_instructions: vec![
                    make_instruction(Opcode::OpConstant, vec![0]),
                    make_instruction(Opcode::OpSetGlobal, vec![0]),
                    make_instruction(Opcode::OpConstant, vec![1]),
                    make_instruction(Opcode::OpSetGlobal, vec![1]),
                ]
                .into_iter()
                .flatten()
                .collect(),
            },
            CompilerTestCase {
                input: "
                const one = 1;
                one;
            "
                .to_string(),
                expected_constants: vec![Object::Integer(1)],
                expected_instructions: vec![
                    make_instruction(Opcode::OpConstant, vec![0]),
                    make_instruction(Opcode::OpSetGlobal, vec![0]),
                    make_instruction(Opcode::OpGetGlobal, vec![0]),
                    make_instruction(Opcode::OpPop, vec![]),
                ]
                .into_iter()
                .flatten()
                .collect(),
            },
            CompilerTestCase {
                input: "
                const one = 1;
                const two = one;
                two;
            "
                .to_string(),
                expected_constants: vec![Object::Integer(1)],
                expected_instructions: vec![
                    make_instruction(Opcode::OpConstant, vec![0]),
                    make_instruction(Opcode::OpSetGlobal, vec![0]),
                    make_instruction(Opcode::OpGetGlobal, vec![0]),
                    make_instruction(Opcode::OpSetGlobal, vec![1]),
                    make_instruction(Opcode::OpGetGlobal, vec![1]),
                    make_instruction(Opcode::OpPop, vec![]),
                ]
                .into_iter()
                .flatten()
                .collect(),
            },
        ];

        run_compiler_tests(tests);
    }

    #[test]
    fn test_string_expressions() {
        let tests = vec![
            CompilerTestCase {
                input: "\"monkey\"".to_string(),
                expected_constants: vec![Object::Str("monkey".to_string())],
                expected_instructions: vec![
                    make_instruction(Opcode::OpConstant, vec![0]),
                    make_instruction(Opcode::OpPop, vec![]),
                ]
                .into_iter()
                .flatten()
                .collect(),
            },
            CompilerTestCase {
                input: "\"mon\" + \"key\"".to_string(),
                expected_constants: vec![
                    Object::Str("mon".to_string()),
                    Object::Str("key".to_string()),
                ],
                expected_instructions: vec![
                    make_instruction(Opcode::OpConstant, vec![0]),
                    make_instruction(Opcode::OpConstant, vec![1]),
                    make_instruction(Opcode::OpAdd, vec![]),
                    make_instruction(Opcode::OpPop, vec![]),
                ]
                .into_iter()
                .flatten()
                .collect(),
            },
        ];

        run_compiler_tests(tests);
    }

    #[test]
    fn test_array_literals() {
        let tests = vec![
            CompilerTestCase {
                input: "[]".to_string(),
                expected_constants: vec![],
                expected_instructions: vec![
                    make_instruction(Opcode::OpArray, vec![0]),
                    make_instruction(Opcode::OpPop, vec![]),
                ]
                .into_iter()
                .flatten()
                .collect(),
            },
            CompilerTestCase {
                input: "[1, 2, 3]".to_string(),
                expected_constants: vec![
                    Object::Integer(1),
                    Object::Integer(2),
                    Object::Integer(3),
                ],
                expected_instructions: vec![
                    make_instruction(Opcode::OpConstant, vec![0]),
                    make_instruction(Opcode::OpConstant, vec![1]),
                    make_instruction(Opcode::OpConstant, vec![2]),
                    make_instruction(Opcode::OpArray, vec![3]),
                    make_instruction(Opcode::OpPop, vec![]),
                ]
                .into_iter()
                .flatten()
                .collect(),
            },
            CompilerTestCase {
                input: "[1 + 2, 3 - 4, 5 * 6]".to_string(),
                expected_constants: vec![
                    Object::Integer(1),
                    Object::Integer(2),
                    Object::Integer(3),
                    Object::Integer(4),
                    Object::Integer(5),
                    Object::Integer(6),
                ],
                expected_instructions: vec![
                    make_instruction(Opcode::OpConstant, vec![0]),
                    make_instruction(Opcode::OpConstant, vec![1]),
                    make_instruction(Opcode::OpAdd, vec![]),
                    make_instruction(Opcode::OpConstant, vec![2]),
                    make_instruction(Opcode::OpConstant, vec![3]),
                    make_instruction(Opcode::OpSub, vec![]),
                    make_instruction(Opcode::OpConstant, vec![4]),
                    make_instruction(Opcode::OpConstant, vec![5]),
                    make_instruction(Opcode::OpMul, vec![]),
                    make_instruction(Opcode::OpArray, vec![3]),
                    make_instruction(Opcode::OpPop, vec![]),
                ]
                .into_iter()
                .flatten()
                .collect(),
            },
        ];

        run_compiler_tests(tests);
    }

    #[test]
    fn test_hash_literals() {
        let tests = vec![
            CompilerTestCase {
                input: "{}".to_string(),
                expected_constants: vec![],
                expected_instructions: vec![
                    make_instruction(Opcode::OpHash, vec![0]),
                    make_instruction(Opcode::OpPop, vec![]),
                ]
                .into_iter()
                .flatten()
                .collect(),
            },
            CompilerTestCase {
                input: "{1: 2, 3: 4, 5: 6}".to_string(),
                expected_constants: vec![
                    Object::Integer(1),
                    Object::Integer(2),
                    Object::Integer(3),
                    Object::Integer(4),
                    Object::Integer(5),
                    Object::Integer(6),
                ],
                expected_instructions: vec![
                    make_instruction(Opcode::OpConstant, vec![0]),
                    make_instruction(Opcode::OpConstant, vec![1]),
                    make_instruction(Opcode::OpConstant, vec![2]),
                    make_instruction(Opcode::OpConstant, vec![3]),
                    make_instruction(Opcode::OpConstant, vec![4]),
                    make_instruction(Opcode::OpConstant, vec![5]),
                    make_instruction(Opcode::OpHash, vec![6]),
                    make_instruction(Opcode::OpPop, vec![]),
                ]
                .into_iter()
                .flatten()
                .collect(),
            },
            CompilerTestCase {
                input: "{1: 2 + 3, 4: 5 * 6}".to_string(),
                expected_constants: vec![
                    Object::Integer(1),
                    Object::Integer(2),
                    Object::Integer(3),
                    Object::Integer(4),
                    Object::Integer(5),
                    Object::Integer(6),
                ],
                expected_instructions: vec![
                    make_instruction(Opcode::OpConstant, vec![0]),
                    make_instruction(Opcode::OpConstant, vec![1]),
                    make_instruction(Opcode::OpConstant, vec![2]),
                    make_instruction(Opcode::OpAdd, vec![]),
                    make_instruction(Opcode::OpConstant, vec![3]),
                    make_instruction(Opcode::OpConstant, vec![4]),
                    make_instruction(Opcode::OpConstant, vec![5]),
                    make_instruction(Opcode::OpMul, vec![]),
                    make_instruction(Opcode::OpHash, vec![4]),
                    make_instruction(Opcode::OpPop, vec![]),
                ]
                .into_iter()
                .flatten()
                .collect(),
            },
        ];

        run_compiler_tests(tests);
    }

    #[test]
    fn test_index_expressions() {
        let tests = vec![
            CompilerTestCase {
                input: "[1, 2, 3][1 + 1]".to_string(),
                expected_constants: vec![
                    Object::Integer(1),
                    Object::Integer(2),
                    Object::Integer(3),
                    Object::Integer(1),
                    Object::Integer(1),
                ],
                expected_instructions: vec![
                    make_instruction(Opcode::OpConstant, vec![0]),
                    make_instruction(Opcode::OpConstant, vec![1]),
                    make_instruction(Opcode::OpConstant, vec![2]),
                    make_instruction(Opcode::OpArray, vec![3]),
                    make_instruction(Opcode::OpConstant, vec![3]),
                    make_instruction(Opcode::OpConstant, vec![4]),
                    make_instruction(Opcode::OpAdd, vec![]),
                    make_instruction(Opcode::OpIndex, vec![]),
                    make_instruction(Opcode::OpPop, vec![]),
                ]
                .into_iter()
                .flatten()
                .collect(),
            },
            CompilerTestCase {
                input: "{1: 2}[2 - 1]".to_string(),
                expected_constants: vec![
                    Object::Integer(1),
                    Object::Integer(2),
                    Object::Integer(2),
                    Object::Integer(1),
                ],
                expected_instructions: vec![
                    make_instruction(Opcode::OpConstant, vec![0]),
                    make_instruction(Opcode::OpConstant, vec![1]),
                    make_instruction(Opcode::OpHash, vec![2]),
                    make_instruction(Opcode::OpConstant, vec![2]),
                    make_instruction(Opcode::OpConstant, vec![3]),
                    make_instruction(Opcode::OpSub, vec![]),
                    make_instruction(Opcode::OpIndex, vec![]),
                    make_instruction(Opcode::OpPop, vec![]),
                ]
                .into_iter()
                .flatten()
                .collect(),
            },
        ];

        run_compiler_tests(tests);
    }

    #[test]
    fn test_functions() {
        let tests = vec![
            CompilerTestCase {
                input: "func() { return 5 + 10 }".to_string(),
                expected_constants: vec![
                    Object::Integer(5),
                    Object::Integer(10),
                    Object::CompiledFunc(&CompiledFuncObject {
                        instructions: Instructions::new(
                            vec![
                                make_instruction(Opcode::OpConstant, vec![0]),
                                make_instruction(Opcode::OpConstant, vec![1]),
                                make_instruction(Opcode::OpAdd, vec![]),
                                make_instruction(Opcode::OpReturnValue, vec![]),
                            ]
                            .into_iter()
                            .flatten()
                            .collect(),
                        ),
                        num_locals: 0,
                        num_params: 0,
                    }),
                ],
                expected_instructions: vec![
                    make_instruction(Opcode::OpClosure, vec![2, 0]),
                    make_instruction(Opcode::OpPop, vec![]),
                ]
                .into_iter()
                .flatten()
                .collect(),
            },
            CompilerTestCase {
                input: "func() { 5 + 10 }".to_string(),
                expected_constants: vec![
                    Object::Integer(5),
                    Object::Integer(10),
                    Object::CompiledFunc(&CompiledFuncObject {
                        instructions: Instructions::new(
                            vec![
                                make_instruction(Opcode::OpConstant, vec![0]),
                                make_instruction(Opcode::OpConstant, vec![1]),
                                make_instruction(Opcode::OpAdd, vec![]),
                                make_instruction(Opcode::OpReturnValue, vec![]),
                            ]
                            .into_iter()
                            .flatten()
                            .collect(),
                        ),
                        num_locals: 0,
                        num_params: 0,
                    }),
                ],
                expected_instructions: vec![
                    make_instruction(Opcode::OpClosure, vec![2, 0]),
                    make_instruction(Opcode::OpPop, vec![]),
                ]
                .into_iter()
                .flatten()
                .collect(),
            },
            CompilerTestCase {
                input: "func() { 1; 2 }".to_string(),
                expected_constants: vec![
                    Object::Integer(1),
                    Object::Integer(2),
                    Object::CompiledFunc(&CompiledFuncObject {
                        instructions: Instructions::new(
                            vec![
                                make_instruction(Opcode::OpConstant, vec![0]),
                                make_instruction(Opcode::OpPop, vec![]),
                                make_instruction(Opcode::OpConstant, vec![1]),
                                make_instruction(Opcode::OpReturnValue, vec![]),
                            ]
                            .into_iter()
                            .flatten()
                            .collect(),
                        ),
                        num_locals: 0,
                        num_params: 0,
                    }),
                ],
                expected_instructions: vec![
                    make_instruction(Opcode::OpClosure, vec![2, 0]),
                    make_instruction(Opcode::OpPop, vec![]),
                ]
                .into_iter()
                .flatten()
                .collect(),
            },
        ];

        run_compiler_tests(tests);
    }

    #[test]
    fn test_function_calls() {
        let tests = vec![
            CompilerTestCase {
                input: "func() { 24 }();".to_string(),
                expected_constants: vec![
                    Object::Integer(24),
                    Object::CompiledFunc(&CompiledFuncObject {
                        instructions: Instructions::new(
                            vec![
                                make_instruction(Opcode::OpConstant, vec![0]),
                                make_instruction(Opcode::OpReturnValue, vec![]),
                            ]
                            .into_iter()
                            .flatten()
                            .collect(),
                        ),
                        num_locals: 0,
                        num_params: 0,
                    }),
                ],
                expected_instructions: vec![
                    make_instruction(Opcode::OpClosure, vec![1, 0]),
                    make_instruction(Opcode::OpCall, vec![0]),
                    make_instruction(Opcode::OpPop, vec![]),
                ]
                .into_iter()
                .flatten()
                .collect(),
            },
            CompilerTestCase {
                input: "let noArg = func() { 24 }; noArg();".to_string(),
                expected_constants: vec![
                    Object::Integer(24),
                    Object::CompiledFunc(&CompiledFuncObject {
                        instructions: Instructions::new(
                            vec![
                                make_instruction(Opcode::OpConstant, vec![0]),
                                make_instruction(Opcode::OpReturnValue, vec![]),
                            ]
                            .into_iter()
                            .flatten()
                            .collect(),
                        ),
                        num_locals: 0,
                        num_params: 0,
                    }),
                ],
                expected_instructions: vec![
                    make_instruction(Opcode::OpClosure, vec![1, 0]),
                    make_instruction(Opcode::OpSetGlobal, vec![0]),
                    make_instruction(Opcode::OpGetGlobal, vec![0]),
                    make_instruction(Opcode::OpCall, vec![0]),
                    make_instruction(Opcode::OpPop, vec![]),
                ]
                .into_iter()
                .flatten()
                .collect(),
            },
            CompilerTestCase {
                input: "let oneArg = func(a) { a }; oneArg(24);".to_string(),
                expected_constants: vec![
                    Object::CompiledFunc(&CompiledFuncObject {
                        instructions: Instructions::new(
                            vec![
                                make_instruction(Opcode::OpGetLocal, vec![0]),
                                make_instruction(Opcode::OpReturnValue, vec![]),
                            ]
                            .into_iter()
                            .flatten()
                            .collect(),
                        ),
                        num_locals: 0,
                        num_params: 0,
                    }),
                    Object::Integer(24),
                ],
                expected_instructions: vec![
                    make_instruction(Opcode::OpClosure, vec![0, 0]),
                    make_instruction(Opcode::OpSetGlobal, vec![0]),
                    make_instruction(Opcode::OpGetGlobal, vec![0]),
                    make_instruction(Opcode::OpConstant, vec![1]),
                    make_instruction(Opcode::OpCall, vec![1]),
                    make_instruction(Opcode::OpPop, vec![]),
                ]
                .into_iter()
                .flatten()
                .collect(),
            },
            CompilerTestCase {
                input: "let manyArg = func(a, b, c) { a; b; c }; manyArg(24, 25, 26);".to_string(),
                expected_constants: vec![
                    Object::CompiledFunc(&CompiledFuncObject {
                        instructions: Instructions::new(
                            vec![
                                make_instruction(Opcode::OpGetLocal, vec![0]),
                                make_instruction(Opcode::OpPop, vec![]),
                                make_instruction(Opcode::OpGetLocal, vec![1]),
                                make_instruction(Opcode::OpPop, vec![]),
                                make_instruction(Opcode::OpGetLocal, vec![2]),
                                make_instruction(Opcode::OpReturnValue, vec![]),
                            ]
                            .into_iter()
                            .flatten()
                            .collect(),
                        ),
                        num_locals: 0,
                        num_params: 0,
                    }),
                    Object::Integer(24),
                    Object::Integer(25),
                    Object::Integer(26),
                ],
                expected_instructions: vec![
                    make_instruction(Opcode::OpClosure, vec![0, 0]),
                    make_instruction(Opcode::OpSetGlobal, vec![0]),
                    make_instruction(Opcode::OpGetGlobal, vec![0]),
                    make_instruction(Opcode::OpConstant, vec![1]),
                    make_instruction(Opcode::OpConstant, vec![2]),
                    make_instruction(Opcode::OpConstant, vec![3]),
                    make_instruction(Opcode::OpCall, vec![3]),
                    make_instruction(Opcode::OpPop, vec![]),
                ]
                .into_iter()
                .flatten()
                .collect(),
            },
        ];

        run_compiler_tests(tests);
    }

    #[test]
    fn test_compiler_scopes() {
        let mut compiler = Compiler::new();
        assert_eq!(compiler.scope_index, 0, "initial scope_index should be 0");

        let global_symbol_table = compiler.symbol_table.clone();

        compiler.emit(Opcode::OpMul, vec![]);
        compiler.enter_scope();
        assert_eq!(
            compiler.scope_index, 1,
            "scope_index should be 1 after entering scope"
        );

        compiler.emit(Opcode::OpSub, vec![]);
        assert_eq!(
            compiler.current_instructions().len(),
            1,
            "instructions length should be 1 in the new scope"
        );

        let last = compiler.scopes[compiler.scope_index as usize].last_instruction;
        assert_eq!(
            last.opcode,
            Opcode::OpSub,
            "last_instruction Opcode should be OpSub"
        );
        let com_sym_tab = compiler.symbol_table.get_outer().unwrap();
        assert_eq!(
            com_sym_tab,
            Box::new(global_symbol_table),
            "symbol table should be enclosed in the new scope"
        );

        compiler.leave_scope();
        assert_eq!(
            compiler.scope_index, 0,
            "scope_index should be 0 after leaving scope"
        );
        assert_eq!(
            compiler.symbol_table, global_symbol_table,
            "compiler should restore global symbol table"
        );

        compiler.emit(Opcode::OpAdd, vec![]);
        assert_eq!(
            compiler.current_instructions().len(),
            2,
            "instructions length should be 2 after leaving scope"
        );

        let last = compiler.scopes[compiler.scope_index as usize].last_instruction;
        assert_eq!(
            last.opcode,
            Opcode::OpAdd,
            "last_instruction Opcode should be OpAdd"
        );

        let previous = compiler.scopes[compiler.scope_index as usize].prev_instruction;
        assert_eq!(
            previous.opcode,
            Opcode::OpMul,
            "previousInstruction Opcode should be OpMul"
        );
    }

    #[test]
    fn test_functions_without_return_value() {
        let tests = vec![CompilerTestCase {
            input: "func() { }".to_string(),
            expected_constants: vec![Object::CompiledFunc(&CompiledFuncObject {
                instructions: Instructions::new(
                    vec![make_instruction(Opcode::OpReturn, vec![])]
                        .into_iter()
                        .flatten()
                        .collect(),
                ),
                num_locals: 0,
                num_params: 0,
            })],
            expected_instructions: vec![
                make_instruction(Opcode::OpClosure, vec![0, 0]),
                make_instruction(Opcode::OpPop, vec![]),
            ]
            .into_iter()
            .flatten()
            .collect(),
        }];

        run_compiler_tests(tests);
    }

    #[test]
    fn test_let_statement_scopes() {
        let tests = vec![
            CompilerTestCase {
                input: "
                    let num = 55;
                    func() { num }
                "
                .to_string(),
                expected_constants: vec![
                    Object::Integer(55),
                    Object::CompiledFunc(&CompiledFuncObject {
                        instructions: Instructions::new(
                            vec![
                                make_instruction(Opcode::OpGetGlobal, vec![0]),
                                make_instruction(Opcode::OpReturnValue, vec![]),
                            ]
                            .into_iter()
                            .flatten()
                            .collect(),
                        ),
                        num_locals: 0,
                        num_params: 0,
                    }),
                ],
                expected_instructions: vec![
                    make_instruction(Opcode::OpConstant, vec![0]),
                    make_instruction(Opcode::OpSetGlobal, vec![0]),
                    make_instruction(Opcode::OpClosure, vec![1, 0]),
                    make_instruction(Opcode::OpPop, vec![]),
                ]
                .into_iter()
                .flatten()
                .collect(),
            },
            CompilerTestCase {
                input: "
                    func() {
                        let num = 55;
                        num
                    }
                "
                .to_string(),
                expected_constants: vec![
                    Object::Integer(55),
                    Object::CompiledFunc(&CompiledFuncObject {
                        instructions: Instructions::new(
                            vec![
                                make_instruction(Opcode::OpConstant, vec![0]),
                                make_instruction(Opcode::OpSetLocal, vec![0]),
                                make_instruction(Opcode::OpGetLocal, vec![0]),
                                make_instruction(Opcode::OpReturnValue, vec![]),
                            ]
                            .into_iter()
                            .flatten()
                            .collect(),
                        ),
                        num_locals: 0,
                        num_params: 0,
                    }),
                ],
                expected_instructions: vec![
                    make_instruction(Opcode::OpClosure, vec![1, 0]),
                    make_instruction(Opcode::OpPop, vec![]),
                ]
                .into_iter()
                .flatten()
                .collect(),
            },
            CompilerTestCase {
                input: "
                    func() {
                        let a = 55;
                        let b = 77;
                        a + b
                    }
                "
                .to_string(),
                expected_constants: vec![
                    Object::Integer(55),
                    Object::Integer(77),
                    Object::CompiledFunc(&CompiledFuncObject {
                        instructions: Instructions::new(
                            vec![
                                make_instruction(Opcode::OpConstant, vec![0]),
                                make_instruction(Opcode::OpSetLocal, vec![0]),
                                make_instruction(Opcode::OpConstant, vec![1]),
                                make_instruction(Opcode::OpSetLocal, vec![1]),
                                make_instruction(Opcode::OpGetLocal, vec![0]),
                                make_instruction(Opcode::OpGetLocal, vec![1]),
                                make_instruction(Opcode::OpAdd, vec![]),
                                make_instruction(Opcode::OpReturnValue, vec![]),
                            ]
                            .into_iter()
                            .flatten()
                            .collect(),
                        ),
                        num_locals: 0,
                        num_params: 0,
                    }),
                ],
                expected_instructions: vec![
                    make_instruction(Opcode::OpClosure, vec![2, 0]),
                    make_instruction(Opcode::OpPop, vec![]),
                ]
                .into_iter()
                .flatten()
                .collect(),
            },
        ];

        run_compiler_tests(tests);
    }

    #[test]
    fn test_const_statement_scopes() {
        let tests = vec![
            CompilerTestCase {
                input: "
                    const num = 55;
                    func() { num }
                "
                .to_string(),
                expected_constants: vec![
                    Object::Integer(55),
                    Object::CompiledFunc(&CompiledFuncObject {
                        instructions: Instructions::new(
                            vec![
                                make_instruction(Opcode::OpGetGlobal, vec![0]),
                                make_instruction(Opcode::OpReturnValue, vec![]),
                            ]
                            .into_iter()
                            .flatten()
                            .collect(),
                        ),
                        num_locals: 0,
                        num_params: 0,
                    }),
                ],
                expected_instructions: vec![
                    make_instruction(Opcode::OpConstant, vec![0]),
                    make_instruction(Opcode::OpSetGlobal, vec![0]),
                    make_instruction(Opcode::OpClosure, vec![1, 0]),
                    make_instruction(Opcode::OpPop, vec![]),
                ]
                .into_iter()
                .flatten()
                .collect(),
            },
            CompilerTestCase {
                input: "
                    func() {
                        const num = 55;
                        num
                    }
                "
                .to_string(),
                expected_constants: vec![
                    Object::Integer(55),
                    Object::CompiledFunc(&CompiledFuncObject {
                        instructions: Instructions::new(
                            vec![
                                make_instruction(Opcode::OpConstant, vec![0]),
                                make_instruction(Opcode::OpSetLocal, vec![0]),
                                make_instruction(Opcode::OpGetLocal, vec![0]),
                                make_instruction(Opcode::OpReturnValue, vec![]),
                            ]
                            .into_iter()
                            .flatten()
                            .collect(),
                        ),
                        num_locals: 0,
                        num_params: 0,
                    }),
                ],
                expected_instructions: vec![
                    make_instruction(Opcode::OpClosure, vec![1, 0]),
                    make_instruction(Opcode::OpPop, vec![]),
                ]
                .into_iter()
                .flatten()
                .collect(),
            },
            CompilerTestCase {
                input: "
                    func() {
                        const a = 55;
                        const b = 77;
                        a + b
                    }
                "
                .to_string(),
                expected_constants: vec![
                    Object::Integer(55),
                    Object::Integer(77),
                    Object::CompiledFunc(&CompiledFuncObject {
                        instructions: Instructions::new(
                            vec![
                                make_instruction(Opcode::OpConstant, vec![0]),
                                make_instruction(Opcode::OpSetLocal, vec![0]),
                                make_instruction(Opcode::OpConstant, vec![1]),
                                make_instruction(Opcode::OpSetLocal, vec![1]),
                                make_instruction(Opcode::OpGetLocal, vec![0]),
                                make_instruction(Opcode::OpGetLocal, vec![1]),
                                make_instruction(Opcode::OpAdd, vec![]),
                                make_instruction(Opcode::OpReturnValue, vec![]),
                            ]
                            .into_iter()
                            .flatten()
                            .collect(),
                        ),
                        num_locals: 0,
                        num_params: 0,
                    }),
                ],
                expected_instructions: vec![
                    make_instruction(Opcode::OpClosure, vec![2, 0]),
                    make_instruction(Opcode::OpPop, vec![]),
                ]
                .into_iter()
                .flatten()
                .collect(),
            },
        ];

        run_compiler_tests(tests);
    }

    #[test]
    fn test_builtins() {
        let tests = vec![
            CompilerTestCase {
                input: "
                    len([]);
                    push([], 1);
                    pop([]);
                "
                .to_string(),
                expected_constants: vec![Object::Integer(1)],
                expected_instructions: vec![
                    make_instruction(Opcode::OpGetBuiltin, vec![0]),
                    make_instruction(Opcode::OpArray, vec![0]),
                    make_instruction(Opcode::OpCall, vec![1]),
                    make_instruction(Opcode::OpPop, vec![]),
                    make_instruction(Opcode::OpGetBuiltin, vec![5]),
                    make_instruction(Opcode::OpArray, vec![0]),
                    make_instruction(Opcode::OpConstant, vec![0]),
                    make_instruction(Opcode::OpCall, vec![2]),
                    make_instruction(Opcode::OpPop, vec![]),
                    make_instruction(Opcode::OpGetBuiltin, vec![6]),
                    make_instruction(Opcode::OpArray, vec![0]),
                    make_instruction(Opcode::OpCall, vec![1]),
                    make_instruction(Opcode::OpPop, vec![]),
                ]
                .into_iter()
                .flatten()
                .collect(),
            },
            CompilerTestCase {
                input: "func() { len([]) }".to_string(),
                expected_constants: vec![Object::CompiledFunc(&CompiledFuncObject {
                    instructions: Instructions::new(
                        vec![
                            make_instruction(Opcode::OpGetBuiltin, vec![0]),
                            make_instruction(Opcode::OpArray, vec![0]),
                            make_instruction(Opcode::OpCall, vec![1]),
                            make_instruction(Opcode::OpReturnValue, vec![]),
                        ]
                        .into_iter()
                        .flatten()
                        .collect(),
                    ),
                    num_locals: 0,
                    num_params: 0,
                })],
                expected_instructions: vec![
                    make_instruction(Opcode::OpClosure, vec![0, 0]),
                    make_instruction(Opcode::OpPop, vec![]),
                ]
                .into_iter()
                .flatten()
                .collect(),
            },
        ];

        run_compiler_tests(tests);
    }

    #[test]
    fn test_closures() {
        let tests = vec![
            CompilerTestCase {
                input: "
                    func(a) {
                        func(b) {
                            a + b
                        }
                    }
                "
                .to_string(),
                expected_constants: vec![
                    Object::CompiledFunc(&CompiledFuncObject {
                        instructions: Instructions::new(
                            vec![
                                make_instruction(Opcode::OpGetFree, vec![0]),
                                make_instruction(Opcode::OpGetLocal, vec![0]),
                                make_instruction(Opcode::OpAdd, vec![]),
                                make_instruction(Opcode::OpReturnValue, vec![]),
                            ]
                            .into_iter()
                            .flatten()
                            .collect(),
                        ),
                        num_locals: 1,
                        num_params: 1,
                    }),
                    Object::CompiledFunc(&CompiledFuncObject {
                        instructions: Instructions::new(
                            vec![
                                make_instruction(Opcode::OpGetLocal, vec![0]),
                                make_instruction(Opcode::OpClosure, vec![0, 1]),
                                make_instruction(Opcode::OpReturnValue, vec![]),
                            ]
                            .into_iter()
                            .flatten()
                            .collect(),
                        ),
                        num_locals: 1,
                        num_params: 1,
                    }),
                ],
                expected_instructions: vec![
                    make_instruction(Opcode::OpClosure, vec![1, 0]),
                    make_instruction(Opcode::OpPop, vec![]),
                ]
                .into_iter()
                .flatten()
                .collect(),
            },
            CompilerTestCase {
                input: "
                    func(a) {
                        func(b) {
                            func(c) {
                                a + b + c
                            }
                        }
                    }
                "
                .to_string(),
                expected_constants: vec![
                    Object::CompiledFunc(&CompiledFuncObject {
                        instructions: Instructions::new(
                            vec![
                                make_instruction(Opcode::OpGetFree, vec![0]),
                                make_instruction(Opcode::OpGetFree, vec![1]),
                                make_instruction(Opcode::OpAdd, vec![]),
                                make_instruction(Opcode::OpGetLocal, vec![0]),
                                make_instruction(Opcode::OpAdd, vec![]),
                                make_instruction(Opcode::OpReturnValue, vec![]),
                            ]
                            .into_iter()
                            .flatten()
                            .collect(),
                        ),
                        num_locals: 1,
                        num_params: 1,
                    }),
                    Object::CompiledFunc(&CompiledFuncObject {
                        instructions: Instructions::new(
                            vec![
                                make_instruction(Opcode::OpGetFree, vec![0]),
                                make_instruction(Opcode::OpGetLocal, vec![0]),
                                make_instruction(Opcode::OpClosure, vec![0, 2]),
                                make_instruction(Opcode::OpReturnValue, vec![]),
                            ]
                            .into_iter()
                            .flatten()
                            .collect(),
                        ),
                        num_locals: 1,
                        num_params: 1,
                    }),
                    Object::CompiledFunc(&CompiledFuncObject {
                        instructions: Instructions::new(
                            vec![
                                make_instruction(Opcode::OpGetLocal, vec![0]),
                                make_instruction(Opcode::OpClosure, vec![1, 1]),
                                make_instruction(Opcode::OpReturnValue, vec![]),
                            ]
                            .into_iter()
                            .flatten()
                            .collect(),
                        ),
                        num_locals: 1,
                        num_params: 1,
                    }),
                ],
                expected_instructions: vec![
                    make_instruction(Opcode::OpClosure, vec![2, 0]),
                    make_instruction(Opcode::OpPop, vec![]),
                ]
                .into_iter()
                .flatten()
                .collect(),
            },
            CompilerTestCase {
                input: "
                    let global = 55;

                    func() {
                        let a = 66;

                        func() {
                            let b = 77;

                            func() {
                                let c = 88;

                                global + a + b + c;
                            }
                        }
                    }
                "
                .to_string(),
                expected_constants: vec![
                    Object::Integer(55),
                    Object::Integer(66),
                    Object::Integer(77),
                    Object::Integer(88),
                    Object::CompiledFunc(&CompiledFuncObject {
                        instructions: Instructions::new(
                            vec![
                                make_instruction(Opcode::OpConstant, vec![3]),
                                make_instruction(Opcode::OpSetLocal, vec![0]),
                                make_instruction(Opcode::OpGetGlobal, vec![0]),
                                make_instruction(Opcode::OpGetFree, vec![0]),
                                make_instruction(Opcode::OpAdd, vec![]),
                                make_instruction(Opcode::OpGetFree, vec![1]),
                                make_instruction(Opcode::OpAdd, vec![]),
                                make_instruction(Opcode::OpGetLocal, vec![0]),
                                make_instruction(Opcode::OpAdd, vec![]),
                                make_instruction(Opcode::OpReturnValue, vec![]),
                            ]
                            .into_iter()
                            .flatten()
                            .collect(),
                        ),
                        num_locals: 1,
                        num_params: 1,
                    }),
                    Object::CompiledFunc(&CompiledFuncObject {
                        instructions: Instructions::new(
                            vec![
                                make_instruction(Opcode::OpConstant, vec![2]),
                                make_instruction(Opcode::OpSetLocal, vec![0]),
                                make_instruction(Opcode::OpGetFree, vec![0]),
                                make_instruction(Opcode::OpGetLocal, vec![0]),
                                make_instruction(Opcode::OpClosure, vec![4, 2]),
                                make_instruction(Opcode::OpReturnValue, vec![]),
                            ]
                            .into_iter()
                            .flatten()
                            .collect(),
                        ),
                        num_locals: 1,
                        num_params: 1,
                    }),
                    Object::CompiledFunc(&CompiledFuncObject {
                        instructions: Instructions::new(
                            vec![
                                make_instruction(Opcode::OpConstant, vec![1]),
                                make_instruction(Opcode::OpSetLocal, vec![0]),
                                make_instruction(Opcode::OpGetLocal, vec![0]),
                                make_instruction(Opcode::OpClosure, vec![5, 1]),
                                make_instruction(Opcode::OpReturnValue, vec![]),
                            ]
                            .into_iter()
                            .flatten()
                            .collect(),
                        ),
                        num_locals: 1,
                        num_params: 1,
                    }),
                ],
                expected_instructions: vec![
                    make_instruction(Opcode::OpConstant, vec![0]),
                    make_instruction(Opcode::OpSetGlobal, vec![0]),
                    make_instruction(Opcode::OpClosure, vec![6, 0]),
                    make_instruction(Opcode::OpPop, vec![]),
                ]
                .into_iter()
                .flatten()
                .collect(),
            },
        ];

        run_compiler_tests(tests);
    }

    #[test]
    fn test_recursive_functions() {
        let tests = vec![
            CompilerTestCase {
                input: "
                    let countDown = func(x) { countDown(x - 1); };
                    countDown(1);
                "
                .to_string(),
                expected_constants: vec![
                    Object::Integer(1),
                    Object::CompiledFunc(&CompiledFuncObject {
                        instructions: Instructions::new(
                            vec![
                                make_instruction(Opcode::OpCurrentClosure, vec![]),
                                make_instruction(Opcode::OpGetLocal, vec![0]),
                                make_instruction(Opcode::OpConstant, vec![0]),
                                make_instruction(Opcode::OpSub, vec![]),
                                make_instruction(Opcode::OpCall, vec![1]),
                                make_instruction(Opcode::OpReturnValue, vec![]),
                            ]
                            .into_iter()
                            .flatten()
                            .collect(),
                        ),
                        num_locals: 1,
                        num_params: 1,
                    }),
                    Object::Integer(1),
                ],
                expected_instructions: vec![
                    make_instruction(Opcode::OpClosure, vec![1, 0]),
                    make_instruction(Opcode::OpSetGlobal, vec![0]),
                    make_instruction(Opcode::OpGetGlobal, vec![0]),
                    make_instruction(Opcode::OpConstant, vec![2]),
                    make_instruction(Opcode::OpCall, vec![1]),
                    make_instruction(Opcode::OpPop, vec![]),
                ]
                .into_iter()
                .flatten()
                .collect(),
            },
            CompilerTestCase {
                input: "
                    let wrapper = func() {
                        let countDown = func(x) { countDown(x - 1); };
                        countDown(1);
                    };
                    wrapper();
                "
                .to_string(),
                expected_constants: vec![
                    Object::Integer(1),
                    Object::CompiledFunc(&CompiledFuncObject {
                        instructions: Instructions::new(
                            vec![
                                make_instruction(Opcode::OpCurrentClosure, vec![]),
                                make_instruction(Opcode::OpGetLocal, vec![0]),
                                make_instruction(Opcode::OpConstant, vec![0]),
                                make_instruction(Opcode::OpSub, vec![]),
                                make_instruction(Opcode::OpCall, vec![1]),
                                make_instruction(Opcode::OpReturnValue, vec![]),
                            ]
                            .into_iter()
                            .flatten()
                            .collect(),
                        ),
                        num_locals: 1,
                        num_params: 1,
                    }),
                    Object::Integer(1),
                    Object::CompiledFunc(&CompiledFuncObject {
                        instructions: Instructions::new(
                            vec![
                                make_instruction(Opcode::OpClosure, vec![1, 0]),
                                make_instruction(Opcode::OpSetLocal, vec![0]),
                                make_instruction(Opcode::OpGetLocal, vec![0]),
                                make_instruction(Opcode::OpConstant, vec![2]),
                                make_instruction(Opcode::OpCall, vec![1]),
                                make_instruction(Opcode::OpReturnValue, vec![]),
                            ]
                            .into_iter()
                            .flatten()
                            .collect(),
                        ),
                        num_locals: 1,
                        num_params: 0,
                    }),
                ],
                expected_instructions: vec![
                    make_instruction(Opcode::OpClosure, vec![3, 0]),
                    make_instruction(Opcode::OpSetGlobal, vec![0]),
                    make_instruction(Opcode::OpGetGlobal, vec![0]),
                    make_instruction(Opcode::OpCall, vec![0]),
                    make_instruction(Opcode::OpPop, vec![]),
                ]
                .into_iter()
                .flatten()
                .collect(),
            },
        ];

        run_compiler_tests(tests);
    }
}
